package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"text/template"

	"github.com/huawei-cloudfederation/mesos-go-stateful/common/logs"
	typ "github.com/huawei-cloudfederation/mesos-go-stateful/common/types"
)

const ExecutorGo = `
//This is an autoGenerated code by the template

package main

import (

	"github.com/huawei-cloudfederation/mesos-go-stateful/common/logs"
	typ "github.com/huawei-cloudfederation/mesos-go-stateful/common/types"
	"github.com/huawei-cloudfederation/mesos-go-stateful/Executor"
)


type {{.Name}}Executor struct {
	IsInit bool
}


func (S *{{.Name}}Executor) Config(T *typ.Task)  {
	logs.Printf("{{.Name}}Executor: configure Task %v", T)
}

func (S *{{.Name}}Executor) TaskStarted(T *typ.Task)  {
	logs.Printf("{{.Name}}Executor: Task Started %v", T)
}

func (S *{{.Name}}Executor) Cleanup(T *typ.Task)  {
	logs.Printf("{{.Name}}Executor: Task Cleanup %v", T)
}

func (S *{{.Name}}Executor) UpdateConfig(T *typ.Task)  {
	logs.Printf("{{.Name}}Executor: Task Cleanup %v", T)
}


func main() {

	logs.Printf("Starting Custom Executor")
	SE :=  {{.Name}}Executor{IsInit:true}
	Executor.Run(&SE)

}
`

const SchedulerGO = `
//This is an autoGenerated code by the template

package main

import (
	"flag"

	"github.com/huawei-cloudfederation/mesos-go-stateful/common/logs"
	typ "github.com/huawei-cloudfederation/mesos-go-stateful/common/types"
	"github.com/huawei-cloudfederation/mesos-go-stateful/sched"
)

type {{.Name}}Scheduler struct {
	Name           string
	Master         string
	CPU, MEM, DISK int64
}

func (S *{{.Name}}Scheduler) Config(I *typ.Instance, IsMaster bool) []string {
	var CmdInfo []string
	logs.Println("start scheduler")

	return CmdInfo 
}

func (S *{{.Name}}Scheduler) Start(I *typ.Instance) error {
	logs.Println("start scheduler")

	return nil
}

func (S *{{.Name}}Scheduler) StartMaster(I *typ.Instance) error {
	logs.Println("start  master")

	return nil
}

func (S *{{.Name}}Scheduler) StartSlave(I *typ.Instance) error {
	logs.Println("start slaves")

	return nil
}

func (S *{{.Name}}Scheduler) MasterRunning(I *typ.Instance) error {
	logs.Println(" master is running")

	return nil
}

func (S *{{.Name}}Scheduler) SlaveRunning(I *typ.Instance) error {
	logs.Println(" slave is running")

	return nil
}

func (S *{{.Name}}Scheduler) MasterLost(I *typ.Instance) error {
	logs.Println(" master has been loast")

	return nil
}

func (S *{{.Name}}Scheduler) SlaveLost(I *typ.Instance) error {
	logs.Println("slave  has been loast")

	return nil
}

func New{{.Name}}Scheduler() *{{.Name}}Scheduler {
	return &{{.Name}}Scheduler{}
}

func main() {

	//Parse Config and command arguments
	ConfigFileName := flag.String("config", "../Config/config.json", "Location of the config file")
	flag.Parse()

	//Enable / overide  the stderr flag
	flag.Lookup("alsologtostderr").Value.Set("true")

	sched.Register(New{{.Name}}Scheduler())

	logs.Printf("Scheduler terminated")

	sched.Init(*ConfigFileName)

	logs.Printf("Scheduler terminated")

}
`

// Define a template.
// Prepare some data to insert into the template.
type Project struct {
	Name string //Name of the project
}

func main() {
	var err error

	Name := flag.String("name", "Example", "Name of the scheduler eg: RedisScheduler or MySQLScheduler")
	Path := flag.String("path", "./", "Path where the project needs to be created")
	flag.Parse()

	//Define the default loging
	flag.Lookup("logtostderr").Value.Set("true")

	/* Defile Project Paths */
	ProjDir := *Path + "/" + *Name
	SchedDir := ProjDir + "/Scheduler"
	ExecDir := ProjDir + "/Executor"
	ConfDir := ProjDir + "/Config"

	// Create all the nessary directories for the project
	logs.Printf("Creating Sub-directories at %s.....", ProjDir)
	err = os.Mkdir(ProjDir, os.ModePerm|os.ModeDir)
	if err != nil {
		logs.Printf("Unable to create dir %s%s", *Path, *Name)
		return
	}

	err = os.Mkdir(SchedDir, os.ModePerm|os.ModeDir)
	if err != nil {
		logs.Printf("Unable to create dir %s%s", *Path, *Name)
		return
	}
	err = os.Mkdir(ExecDir, os.ModePerm|os.ModeDir)
	if err != nil {
		logs.Printf("Unable to create dir %s%s", *Path, *Name)
		return
	}
	err = os.Mkdir(ConfDir, os.ModePerm|os.ModeDir)
	if err != nil {
		logs.Printf("Unable to create dir %s%s", *Path, *Name)
		return
	}

	//Process the template
	logs.Printf("Generating Scheduler.go...")
	workinfo := Project{Name: *Name}
	// Create a new template and parse the letter into it.
	t := template.Must(template.New("SchedulerGO").Parse(SchedulerGO))

	// Execute the template for the scheduler
	f, err := os.Create(SchedDir + "/Scheduler.go")
	if err != nil {
		logs.Printf("Unable to create scheduler file %v", err)
		return
	}
	err = t.Execute(f, workinfo)
	if err != nil {
		logs.Println("executing template:", err)
	}
	f.Close()

	tE := template.Must(template.New("ExecutorGO").Parse(ExecutorGo))

	// Execute the template for the scheduler
	fE, err := os.Create(ExecDir + "/" + *Name + "Executor.go")
	if err != nil {
		logs.Printf("Unable to create scheduler file %v", err)
		return
	}
	err = tE.Execute(fE, workinfo)
	if err != nil {
		logs.Println("executing template:", err)
	}
	fE.Close()

	//Generate Config file
	logs.Printf("Generating autofilled config file")

	Cfg := typ.NewDefaultConfig()
	Cfg.FrameworkName = *Name
	Cfg.WorkLoad.Image = ""
	Cfg.UserName = "root"
	Cfg.ExecutorPath = fmt.Sprintf("%s/%sExecutor", ExecDir, *Name)
	confBytes, err := json.MarshalIndent(&Cfg, " ", "  ")
	if err != nil {
		logs.Printf("Json Marshall error %v", err)
		return
	}
	f, err = os.Create(ConfDir + "/config.json")
	if err != nil {
		logs.Printf("Unable to create config file %v", err)
		return
	}
	f.Write(confBytes)
	f.Close()

	//Generate the Executor
	logs.Printf("Project Generation Completed")

}
